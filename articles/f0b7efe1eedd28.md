---
title: "ハッシュツリー"
emoji: "🌲"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Blockchain", "Bitcoin", "Python"]
published: false
---

# 概要
ブロックチェーン技術に関する記事を読んでいると頻繁にハッシュツリーという単語がでてくるので理解のため実装して動作確認してみました。

# ハッシュツリーって何なの？
<!-- TODO: 自分の言葉で -->
ハッシュツリーとは、データ群の要約を作成し、要約と元データの整合性を見ることで、改ざんが行われてないか検証をする技術です。その際に、データ群の一部のみを知ってるだけで、検証が可能な事がポイントとなります。

軽量クライアントはブロックチェーンデータを保持できる要領ではないため、マークルルートを含むブロックの要約（Block Header)のみを、walletは保持します。

# ハッシュツリーの構成はこんな感じ
サトシナカモトの論文、[Transactions Hashed in a Merkle Tree](https://bitcoin.org/bitcoin.pdf)が分かり易かったです

ハッシュツリーの最下層には位置する順序付きハッシュリストを`リーフ`と呼びます。ここには

リーフ以外のハッシュツリーのノード群を`内部ノード`と呼びます。

各深さにおいてハッシュは常に順序的なアイデンティティを持つことから各ペアのハッシュをそれぞれ左ハッシュ、右ハッシュと呼びます。

そして、全ハッシュの親レベルを`マークルルート`と呼びます。

このマークルルートを求めることで各ブロック内のトランザクションの情報にアクセスするキーを軽量クライアントが保持できるようになります。

# ハッシュツリーで何を保証できるのか







# これを解決するのがハッシュツリー










# 実装方法
アイテムの順序付きリストを暗号学的ハッシュ関数でハッシュ化していき、ただ一つの一意なハッシュに定まるまで２つのハッシュをペアにして連結させていく処理を繰り返す。この過程で大切なことは１ループ単位のハッシュの個数は必ず偶数でなければならないこと。つまり、任意のループでハッシュのペアが存在しない場合、末尾のハッシュを複製しそのハッシュ同士を連結させて新たな親ハッシュを作成する。具体的に言うと各ペアの親ハッシュを計算できるようになるには少なくとも３つ以上の順序付きのハッシュリストが必要になる。この条件をマークルペアレントレベルと呼ぶ。言い換えればマークルルートを求めるためにはこのハッシュの個数が１になるまでマークルペアレントレベルを計算する。










## 1







## 2










## 3












# おまけ：なぜハッシュ同士を連結して親ハッシュを求めるの？
包含証明を提供できるため。

ここまででハッシュのペアをお互いに連結してハッシュ化していけばマークルルートが求まり、その情報をもとにブロック内の情報を軽量クライアントが理解できるんだなあというところまでわかりましたが、、、そもそもなぜハッシュ同士を連結して親ハッシュを求めるのでしょう？





https://zenn.dev/dowanna6/articles/92c6494570a4dc