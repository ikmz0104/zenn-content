---
title: "【Python】ハッシュツリー 実装しました"
emoji: "🌲"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Blockchain", "Bitcoin", "Python"]
published: false
---

# 概要
ブロックチェーン技術に関する記事を読んでいると頻繁にハッシュツリーという単語がでてくるので理解のため実装して動作確認してみました。

こちらが今回実装したソースです。
https://github.com/ikmz0104/merkle-root/blob/main/main.ipynb

# ハッシュツリーって何なの？
<!-- TODO: 自分の言葉で -->
ハッシュツリーとは、データ群の要約を作成し、要約と元データの整合性を見ることで、改ざんが行われてないか検証をする技術です。その際に、データ群の一部のみを知ってるだけで、検証が可能な事がポイントとなります。

軽量クライアントはブロックチェーンデータを保持できる要領ではないため、マークルルートを含むブロックの要約（Block Header)のみを、walletは保持します。

# ハッシュツリーの構成はこんな感じ
サトシナカモトの論文、[Transactions Hashed in a Merkle Tree](https://bitcoin.org/bitcoin.pdf)が分かり易かったです

ハッシュツリーの最下層には位置する順序付きハッシュリストを`リーフ`と呼びます。ここには

リーフ以外のハッシュツリーのノード群を`内部ノード`と呼びます。

各深さにおいてハッシュは常に順序的なアイデンティティを持つことから各ペアのハッシュをそれぞれ左ハッシュ、右ハッシュと呼びます。

そして、全ハッシュの親レベルを`マークルルート`と呼びます。

このマークルルートを求めることで各ブロック内のトランザクションの情報にアクセスするキーを軽量クライアントが保持できるようになります。

# 実装方法
1. 好きなハッシュ関数を使って、順序的リストの要素全てをハッシュ化する
2. ハッシュの個数が奇数なら末尾のハッシュを複製して偶数にする
3. ハッシュをペアにして連結し新たなハッシュを生成
4. 2～4を繰り返す（ハッシュの個数が1になれば終了）

※暗号学的ハッシュ関数-HASH256

# 動作確認
## 1
順序付きハッシュリストをハッシュ化して、インプット用のハッシュを準備
```
hexHashes = [
    'c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5',
    'c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5',
    'f391da6ecfeed1814efae39e7fcb3838ae0b02c02ae7d0a5848a66947c0727b0',
    '3d238a92a94532b946c90e19c49351c763696cff3db400485b813aecb8a13181',
    '10092f2633be5f3ce349bf9ddbde36caa3dd10dfa0ec8106bce23acbff637dae',
]
hashes = [bytes.fromhex(x) for x in hexHashes]
```

## 2
1で求めたハッシュリストにて、ハッシュ数が奇数なら末尾のハッシュ値を複製して連結
```
if len(hashes) % 2 == 1:
    hashes.append(hashes[-1])
```

## 3

```
from helper import hash256
# 左ハッシュ
leftHash = bytes.fromhex('c117ea8ec828342f4dfb0ad6bd140e03a50720ece40169ee38bdc15d9eb64cf5')
# 右ハッシュ
rightHash = bytes.fromhex('c131474164b412e3406696da1ee20ab0fc9bf41c8f05fa8ceea7a08d672d7cc5')
# 親ハッシュ
parent = hash256(leftHash + rightHash)
```





# おまけ：そもそもなぜハッシュ同士を連結して親ハッシュを求めるの？
包含証明を提供できるため。

ここまででハッシュのペアをお互いに連結してハッシュ化していけばマークルルートが求まり、その情報をもとにブロック内の情報を軽量クライアントが理解できるんだなあというところまでわかりましたが、、、そもそもなぜハッシュ同士を連結して親ハッシュを求めるのでしょう？

https://zenn.dev/dowanna6/articles/92c6494570a4dc